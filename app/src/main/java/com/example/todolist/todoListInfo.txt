Для добавления кнопки нужно использовать элемент floatActionButton. Для работы со списками мы должны добавить сам список, в котором мы будем давать значения. Создаем класс Note, в
котором будут указаны id элементов, их важность и текст внутри них. Далее в mainActivity мы создадим список типа Note, в котором будем размещать значения. Так как в основной макет
нельзя вручную добавлять TextView, так как нам заранее неизвестно сколько пользователь введет значений, то мы отдельно будем создавать layout макет для добавления элементов.
В нем корневой элемент как раз будет TextView. Сначала нам нужно преобразовать макет файл формата xml в объект класса View. Для преобразования xml файла в объект класса View
нам нужно вызвать метод getLayoutInflater().inflate(id_макета, view_group_в_который_мы_будем_вставлять_элемент, false). Также в этом приложении мы будем использовать паттерн
проектирования singleton. Он нам нужен тогда, когда мы пользуемся одним и тем же обхектом класса в других классах. Он нужен для того, чтобы объект базы данных в этой программе
создавался один раз.

RecyclerView
Данный вью груп должен быть создан для нашего приложения. Допустим, если пользователь захочет создать N заметок, которые могут доходить и до тысячи штук. С обычным скролл вью
наше приложение будет тормозить, потому что для каждой заметки мы создаем отдельный элемент вью группы. А так как пользователь в среднем видит на экране 10-12 элементов, то
нам и нужно создать только такое количество элементов, а потом просто менять в них значения по мере прокрутки. Нам мало просто создать на макете RecyclerView элемент, мы также
должны создать адаптер. Адаптер должен знать, каким образом создавать вью из макета и каким образом устанавливать значения в эти вью. Поэтому в самом адаптере должна лежать
коллекция объектов, которых мы хотим отобразить. В адаптере в обязателоьном порядке должен быть определен класс ViewHolder. Адаптер работает только с фью группами, никакую
логику для взаимодействия с сетью/бд и так далее добавлять в него не надо, так как это плохо скажется на приложении. Именно реакцию на удаление мы промишем в мэин активити. В
адаптере сделаем интерфейс. Для свайпа мы будем использовать класс ItemTouchHelper. В данном классе мы должны переопределить два метода. Один метод предназначен для перемещения
объектов по экрану, а второй метод - для свайпа вправо или влево.

RoomDatabase
Каждая база данных состоит из таблиц. В левой колонне мы можем найти Gradle scripts. Как раз в build.gradle(Module) мы можем добавлять какие - либо библиотеки. Там мы добавляем
библиотеки в строке Dependencies. Далее мы должны создать класс NoteDatabase, он сам будет асбтрактным, будет унаследован от класса RoomDatabase. Далее создадим интерфейс NotesDao
он нужен для того, чтобы взаимодействовать с самой бд. В самом интерфейсе будут определены методы для работы с бд. Перед методами мы должны исползовать такие аннотации, как:
@Query, @Insert и тд. @Query используется тогда, когда мы хотим написать SQL запрос. @Insert используется тогда, когда мы хотим вставить элемент. С чем я еще столкнулся при построении приложения?
Мы должны сделать так, чтобы запросы и действия с бд работали в другом потоке, иначе эти действия с бд могут заблокировать полностью приложение. То есть, если выполнять долгие
операции на главном потоке, то будет проблема с отрисовкой и так далее. Для реализации многопоточности нам может помочь класс Handler. Он будет содержать ссылку на главный поток.
С элементами вью мы можем работать только из главного потока. Также нам нужно использовать LiveData для отображения списка бд.

        private Handler handler = new Handler(Looper.getMainLooper()); данный класс нужен, например
        для того, чтобы мы могли обратиться к главному потоку тогда, когда нам нужно отрисовать
        вью элемент
        для обращения к главному потоку надо было бы далее дописать внутри отделбных потоков:
        handler.post(new Runnable() {
            @Override
            public void run() {
                ...
            }
        });


MVVM
Данная арзитектура разделяет view, viewModel и model. View отвечает только за отображение данных и взаимодействие с пользователем. ViewModel может взаимодействовать с model и
создавать подписки с view. Model в свою очередь посылает запросы на бэкенд или работа с сетью. В viewModel часто используют класс LivaData. Это такой класс, который по сути следит
за изменениями данного экземпляра класса. Сущесвтует также и MutableLiveData - мы сами теперь можем вносить какие - то изменения в переменную данного типа.


RxJava
Проблема использования обычных потоков состоит в том, что они могут выполняться даже после того, как пользователь закрыл окно, которое он запустил. Произойдет утечка памяти.
Также при использовании класса Thread переключение потоков становится трудной задачей. Thread вообще не рекомендованно при разработке на андроид. Disposable управляет жизненным
циклом потока, чтобы его можно было отменить. subscribe(Schedulers.io()) переключает поток в фоновый режим. observeOn(AndroidSchedulers.mainThread()) переключает поток на основной
Тип данных Completable может сообщать нам о том, что метод завершился или нет. Тип Single позволяет также достать значения из самой переменной, а не только узнавать состояние.
Само подключение RxJava осуществляется через зависимости, при этом в зависимостях мы также должны связать Room с RxJava. Также иногда бывает так, что какие - то бибилиотеки
не поддерживают RxJava. В таких случаях мы должны прописывать реализацию потоков вручную. В метод subscribe() мы можем передавать не только один параметр анонимного класса, но и
второй оюъект анонимного класса. Второй будет задействован для обработки исключений. Исключения всегда надо добавлять при работе с RxJava.